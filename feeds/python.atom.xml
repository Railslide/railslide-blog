<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Railslide</title><link href="http://railslide.io/" rel="alternate"></link><link href="http://railslide.io/feeds/python.atom.xml" rel="self"></link><id>http://railslide.io/</id><updated>2015-01-27T00:00:00+01:00</updated><entry><title>Anaconda VS SublimePythonIDE</title><link href="http://railslide.io/anaconda-vs-sublime-python-ide.html" rel="alternate"></link><updated>2015-01-27T00:00:00+01:00</updated><author><name>Giulia Vergottini</name></author><id>tag:railslide.io,2015-01-27:anaconda-vs-sublime-python-ide.html</id><summary type="html">&lt;p&gt;When I was looking for a python code linting plugin for Sublime Text 3, I stumbled upon several blog posts mentioning either &lt;a href="https://github.com/JulianEberius/SublimePythonIDE"&gt;SublimePythonIDE&lt;/a&gt; or &lt;a href="http://damnwidget.github.io/anaconda/"&gt;Anaconda&lt;/a&gt;. The problem was, however, that a comparison between the two was nowhere to be found, so I ended up trying both.&lt;/p&gt;
&lt;p&gt;The first thing that I have to acknowledge is that they are both very good when it comes to code linting and auto completion. So, no matter which one you choose, you can't really go wrong.&lt;/p&gt;
&lt;p&gt;When it comes to the extras SublimePythonIDE is the one that lacks most. Although this certainly comes with with the price of less flexibility, it isn't necessary a negative thing. Indeed, the strength of SublimePythonIDE is that it works out of the box: just make sure that your project settings point to correct interpreter (I delegate that to &lt;a href="http://github.com/Railslide/subvenv"&gt;Subvenv&lt;/a&gt;) and you're ready to go. Without any further effort from your side, SublimePythonIDE will provide you with fancy linting icons on the gutter and colored linting marks. While the same things can be obtained with Anaconda as well, they still require you to read the docs and tinker with the settings.&lt;/p&gt;
&lt;p&gt;Although they require some initial tuning, the extensive amount of customizable settings are not necessarily a negative things, since they offer you the possibility to adjust the way it looks and feel to suite your taste. On top of that Anaconda provides a bunch of handy IDE-like features, such as &lt;code&gt;Go to definition&lt;/code&gt;, &lt;code&gt;Show documentation&lt;/code&gt;, and &lt;code&gt;Find usage&lt;/code&gt; - all reachable via shortcuts or via command palette. It also comes with &lt;a href="https://github.com/hhatto/autopep8"&gt;AutoPEP8&lt;/a&gt;, McCabe complexity checker, and Vagrant integration (via command palette). Recently also a test runner and an import validator has been added to the already reach set of features.&lt;/p&gt;
&lt;p&gt;So which one is the best? It depends. I have settled on Anaconda, since I really enjoy the &lt;code&gt;Go to definition&lt;/code&gt;, &lt;code&gt;Show documentation&lt;/code&gt;, and &lt;code&gt;Find usage&lt;/code&gt; features and use them quite often - especially when dealing with large projects and/or large files. However, if you need a linter that just works and don't want to spend time in playing around with its configuration, SublimePythonIDE is probably the right choice. On the contrary, you don't mind tinkering a bit with settings files and you are looking for a wider set of IDE-like functions, Anaconda is definitely worthy a shot.&lt;/p&gt;</summary><category term="sublime text"></category><category term="code linting"></category><category term="tools"></category></entry><entry><title>Installing virtualenvwrapper for Python 3.4 on Ubuntu</title><link href="http://railslide.io/virtualenvwrapper-python3.html" rel="alternate"></link><updated>2014-06-04T00:00:00+02:00</updated><author><name>Giulia Vergottini</name></author><id>tag:railslide.io,2014-06-04:virtualenvwrapper-python3.html</id><summary type="html">&lt;p&gt;After listening to an inspiring talk by &lt;a href="http://www.kennethreitz.org/"&gt;Kenneth Reitz&lt;/a&gt; about transitioning from Python 2 to Python 3 at PyCon Sweden (I'll write a blog post about it sooner or later), I've decided that I should try to stick to Python 3 as much as possible.&lt;/p&gt;
&lt;p&gt;So the first step in that direction was to set up my working environment in a Python 3 friendly way, hence to install Virtualenwrapper for Python 3. Here's how I did it.&lt;/p&gt;
&lt;p&gt;Virtualenwrapper documentation specifies that Virtualenvwrapper has been tested under Python 2.6-3.3, but no mention of Python 3.4. Being lazy and not really willing to install a third version of Python on my computer (Ubuntu 14.04 comes with Python 2.7.6 and Python 3.4 by default), I decided to give it try with what I had. Everything seems to work flawlessly so far, just keep it in mind in case you want to try to follow these instructions.&lt;/p&gt;
&lt;h2&gt;Setting up Virtualenvwrapper&lt;/h2&gt;
&lt;p&gt;Install pip for Python 3:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sudo apt-get install python3-pip
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Install Virtualenvwrapper for Python 3:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sudo pip3 install virtualenvwrapper
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;So far so good. Now it is time to configure Virtualenvwrapper.&lt;/p&gt;
&lt;p&gt;Create a folder for your virtualenvs (I use ~/.virtualenvs) and set it as WORKON_HOME:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;mkdir ~/.virtualenvs
&lt;span class="nb"&gt;export &lt;/span&gt;&lt;span class="nv"&gt;WORKON_HOME&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;~/.virtualenvs
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Add the following lines to ~/.bashrc:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;VIRTUALENVWRAPPER_PYTHON=&amp;#39;/usr/bin/python3&amp;#39; # This needs to be placed before the virtualenvwrapper command
source /usr/local/bin/virtualenvwrapper.sh
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Close and re-open your shell and you're ready to go. Here are the basic commands for using virtualenvwrapper:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;mkvirtualenv virtualenv_name &lt;span class="c"&gt;# Create virtualenv&lt;/span&gt;
workon virtualenv_name &lt;span class="c"&gt;# Activate/switch to a virtualenv&lt;/span&gt;
deactivate virtualenv_name &lt;span class="c"&gt;# Deactivate virtualenv&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Congratulations! Your Virtualenvwrapper for Python 3 is now ready to use.&lt;/p&gt;
&lt;h2&gt;Projects&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;EDIT&lt;/strong&gt;: in a previous version of this article, I suggested to use the postactivate script to automatically navigate to the project folder when activating the virtualenv. However, since I discovered that such a task is automatically performed by the projects plugin, I updated the post accordingly.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;While the possibility to have isolated virtual environments just a &lt;code&gt;mkvirtualenv&lt;/code&gt; away had immediately convinced me of the usefulness of Virtualenvwrapper, projects made me falling in love for it.&lt;/p&gt;
&lt;p&gt;My typical workflow is to create a virtualenv and then create a project folder with the same name. So why not setting up Virtualenvwrapper to automatically do it for me every time I create a new virtualenv? Specify PROJECT_HOME in ~/.bashrc will do the trick:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;VIRTUALENVWRAPPER_PYTHON=&amp;#39;/usr/bin/python3&amp;#39;
PROJECT_HOME=&amp;#39;/path/to/where/you/want/your/project/folder/to/be/created&amp;#39; # This needs to be placed before the virtualenvwrapper command as well
source /usr/local/bin/virtualenvwrapper.sh
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Now, when typing&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;mkproject my_project
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Virtualenvwrapper will automatically create a virtualenv and a folder called &lt;em&gt;my_project&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Cherry on top, projects automaticatilly navigates to the project folder when activating the virtualenv. Thus, when typing&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;workon my_project
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Virtualenvwrapper activates the virtualenv and teleports me to ~/Projects/my_project. Neat!&lt;/p&gt;</summary><category term="virtualenvwrapper"></category><category term="virtualenv"></category><category term="python3.4"></category></entry></feed>